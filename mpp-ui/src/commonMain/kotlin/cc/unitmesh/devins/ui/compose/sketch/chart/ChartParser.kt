package cc.unitmesh.devins.ui.compose.sketch.chart

import com.charleskorn.kaml.Yaml
import com.charleskorn.kaml.YamlConfiguration
import kotlinx.serialization.json.Json

/**
 * Parser for chart configuration from YAML or JSON format
 */
object ChartParser {
    private val yaml = Yaml(
        configuration = YamlConfiguration(
            strictMode = false
        )
    )

    private val json = Json {
        ignoreUnknownKeys = true
        isLenient = true
    }

    /**
     * Parse chart configuration from content string
     * Supports both YAML and JSON formats
     */
    fun parse(content: String): ChartConfig? {
        val trimmed = content.trim()
        return try {
            if (trimmed.startsWith("{")) {
                // JSON format
                json.decodeFromString<ChartConfig>(trimmed)
            } else {
                // YAML format - try structured parsing first
                parseStructuredYaml(trimmed)
            }
        } catch (e: Exception) {
            // Try to parse as simple format
            parseSimpleFormat(trimmed)
        }
    }

    /**
     * Parse structured YAML format where type determines data structure.
     * This handles the format generated by ChartAgent:
     * ```yaml
     * type: pie
     * title: "Chart Title"
     * data:
     *   items:
     *     - label: "A"
     *       value: 30
     * ```
     */
    private fun parseStructuredYaml(content: String): ChartConfig? {
        // Extract type from YAML
        val typeMatch = Regex("""type:\s*["']?(\w+)["']?""").find(content)
        val chartType = typeMatch?.groupValues?.get(1)?.lowercase() ?: return parseSimpleFormat(content)

        // Extract title
        val titleMatch = Regex("""title:\s*["']?([^"'\n]+)["']?""").find(content)
        val title = titleMatch?.groupValues?.get(1)?.trim()

        // Extract data section
        val dataMatch = Regex("""data:\s*\n([\s\S]+)""").find(content)
        val dataSection = dataMatch?.groupValues?.get(1) ?: return parseSimpleFormat(content)

        return when (chartType) {
            "pie" -> parsePieDataFromYaml(dataSection, title)
            "line" -> parseLineDataFromYaml(dataSection, title)
            "column", "bar" -> parseColumnDataFromYaml(dataSection, title)
            "row" -> parseRowDataFromYaml(dataSection, title)
            else -> parseSimpleFormat(content)
        }
    }

    /**
     * Parse pie chart data from YAML data section
     */
    private fun parsePieDataFromYaml(dataSection: String, title: String?): ChartConfig? {
        val items = mutableListOf<PieItem>()

        // Match items with label, value, and optional color
        val itemPattern = Regex(
            """-\s*label:\s*["']?([^"'\n]+)["']?\s*\n\s*value:\s*([\d.]+)\s*(?:\n\s*color:\s*["']?([^"'\n]+)["']?)?""",
            RegexOption.MULTILINE
        )

        itemPattern.findAll(dataSection).forEach { match ->
            val label = match.groupValues[1].trim()
            val value = match.groupValues[2].toDoubleOrNull() ?: return@forEach
            val color = match.groupValues.getOrNull(3)?.takeIf { it.isNotBlank() }?.trim()
            items.add(PieItem(label = label, value = value, color = color))
        }

        if (items.isEmpty()) return null

        return ChartConfig(
            type = ChartType.PIE,
            title = title,
            data = ChartDataContent.PieData(items = items)
        )
    }

    /**
     * Parse line chart data from YAML data section
     */
    private fun parseLineDataFromYaml(dataSection: String, title: String?): ChartConfig? {
        val lines = mutableListOf<LineItem>()

        // Match lines with label, values array, and optional color
        val linePattern = Regex(
            """-\s*label:\s*["']?([^"'\n]+)["']?\s*\n\s*values:\s*\[([^\]]+)\]\s*(?:\n\s*color:\s*["']?([^"'\n]+)["']?)?""",
            RegexOption.MULTILINE
        )

        linePattern.findAll(dataSection).forEach { match ->
            val label = match.groupValues[1].trim()
            val valuesStr = match.groupValues[2]
            val values = valuesStr.split(",").mapNotNull { it.trim().toDoubleOrNull() }
            val color = match.groupValues.getOrNull(3)?.takeIf { it.isNotBlank() }?.trim()

            if (values.isNotEmpty()) {
                lines.add(LineItem(label = label, values = values, color = color))
            }
        }

        if (lines.isEmpty()) return null

        return ChartConfig(
            type = ChartType.LINE,
            title = title,
            data = ChartDataContent.LineData(lines = lines)
        )
    }

    /**
     * Parse column chart data from YAML data section
     */
    private fun parseColumnDataFromYaml(dataSection: String, title: String?): ChartConfig? {
        val bars = parseBarGroupsFromYaml(dataSection)
        if (bars.isEmpty()) return null

        return ChartConfig(
            type = ChartType.COLUMN,
            title = title,
            data = ChartDataContent.ColumnData(bars = bars)
        )
    }

    /**
     * Parse row chart data from YAML data section
     */
    private fun parseRowDataFromYaml(dataSection: String, title: String?): ChartConfig? {
        val bars = parseBarGroupsFromYaml(dataSection)
        if (bars.isEmpty()) return null

        return ChartConfig(
            type = ChartType.ROW,
            title = title,
            data = ChartDataContent.RowData(bars = bars)
        )
    }

    /**
     * Parse bar groups from YAML for column/row charts
     */
    private fun parseBarGroupsFromYaml(dataSection: String): List<BarGroup> {
        val bars = mutableListOf<BarGroup>()

        // Match bar groups with label and values
        val barPattern = Regex(
            """-\s*label:\s*["']?([^"'\n]+)["']?\s*\n\s*values:\s*\n((?:\s+-[^\n]+\n?)+)""",
            RegexOption.MULTILINE
        )

        barPattern.findAll(dataSection).forEach { match ->
            val label = match.groupValues[1].trim()
            val valuesSection = match.groupValues[2]

            val values = mutableListOf<BarValue>()
            val valuePattern = Regex("""-\s*value:\s*([\d.]+)(?:\s*\n\s*color:\s*["']?([^"'\n]+)["']?)?""")

            valuePattern.findAll(valuesSection).forEach { valueMatch ->
                val value = valueMatch.groupValues[1].toDoubleOrNull() ?: return@forEach
                val color = valueMatch.groupValues.getOrNull(2)?.takeIf { it.isNotBlank() }?.trim()
                values.add(BarValue(value = value, color = color))
            }

            if (values.isNotEmpty()) {
                bars.add(BarGroup(label = label, values = values))
            }
        }

        return bars
    }

    /**
     * Parse simple DSL format for quick chart creation
     * Format:
     * ```
     * pie:
     *   - Label1: 30
     *   - Label2: 50
     *   - Label3: 20
     * ```
     */
    private fun parseSimpleFormat(content: String): ChartConfig? {
        val lines = content.lines().map { it.trim() }.filter { it.isNotEmpty() }
        if (lines.isEmpty()) return null

        val firstLine = lines.first().lowercase()

        return when {
            firstLine.startsWith("pie") -> parseSimplePie(lines.drop(1))
            firstLine.startsWith("line") -> parseSimpleLine(lines.drop(1))
            firstLine.startsWith("column") || firstLine.startsWith("bar") -> parseSimpleColumn(lines.drop(1))
            firstLine.startsWith("row") -> parseSimpleRow(lines.drop(1))
            else -> null
        }
    }

    private fun parseSimplePie(lines: List<String>): ChartConfig? {
        val items = lines.mapNotNull { line ->
            val parts = line.removePrefix("-").trim().split(":")
            if (parts.size >= 2) {
                val label = parts[0].trim()
                val value = parts[1].trim().toDoubleOrNull() ?: return@mapNotNull null
                PieItem(label = label, value = value)
            } else null
        }

        if (items.isEmpty()) return null

        return ChartConfig(
            type = ChartType.PIE,
            data = ChartDataContent.PieData(items = items)
        )
    }

    private fun parseSimpleLine(lines: List<String>): ChartConfig? {
        val lineItems = lines.mapNotNull { line ->
            val parts = line.removePrefix("-").trim().split(":")
            if (parts.size >= 2) {
                val label = parts[0].trim()
                val values = parts[1].split(",").mapNotNull { it.trim().toDoubleOrNull() }
                if (values.isNotEmpty()) LineItem(label = label, values = values) else null
            } else null
        }

        if (lineItems.isEmpty()) return null

        return ChartConfig(
            type = ChartType.LINE,
            data = ChartDataContent.LineData(lines = lineItems)
        )
    }

    private fun parseSimpleColumn(lines: List<String>): ChartConfig? {
        val bars = lines.mapNotNull { line ->
            val parts = line.removePrefix("-").trim().split(":")
            if (parts.size >= 2) {
                val label = parts[0].trim()
                val value = parts[1].trim().toDoubleOrNull() ?: return@mapNotNull null
                BarGroup(label = label, values = listOf(BarValue(value = value)))
            } else null
        }

        if (bars.isEmpty()) return null

        return ChartConfig(
            type = ChartType.COLUMN,
            data = ChartDataContent.ColumnData(bars = bars)
        )
    }

    private fun parseSimpleRow(lines: List<String>): ChartConfig? {
        val bars = lines.mapNotNull { line ->
            val parts = line.removePrefix("-").trim().split(":")
            if (parts.size >= 2) {
                val label = parts[0].trim()
                val value = parts[1].trim().toDoubleOrNull() ?: return@mapNotNull null
                BarGroup(label = label, values = listOf(BarValue(value = value)))
            } else null
        }

        if (bars.isEmpty()) return null

        return ChartConfig(
            type = ChartType.ROW,
            data = ChartDataContent.RowData(bars = bars)
        )
    }
}

