<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow DOM Test Page</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 { color: #333; }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Shadow DOM Inspect Test Page</h1>
        
        <div class="test-section">
            <h2>Section 1: Regular DOM Elements</h2>
            <p id="regular-text">This is a regular paragraph element.</p>
            <button id="regular-button">Regular Button</button>
        </div>
        
        <div class="test-section">
            <h2>Section 2: Simple Shadow DOM Component</h2>
            <div id="simple-shadow-host"></div>
        </div>
        
        <div class="test-section">
            <h2>Section 3: Nested Shadow DOM</h2>
            <div id="nested-shadow-host"></div>
        </div>
        
        <div class="test-section">
            <h2>Section 4: Dynamic DOM Changes</h2>
            <div id="dynamic-container">
                <p>Initial content</p>
            </div>
            <button id="add-element">Add Element</button>
            <button id="remove-element">Remove Element</button>
            <button id="modify-element">Modify Element</button>
        </div>
        
        <div class="test-section">
            <h2>Section 5: Web Component</h2>
            <custom-card title="Test Card" description="This is a custom web component with shadow DOM"></custom-card>
        </div>
    </div>

    <script>
        // Simple Shadow DOM Component
        const simpleShadowHost = document.getElementById('simple-shadow-host');
        const simpleShadow = simpleShadowHost.attachShadow({ mode: 'open' });
        simpleShadow.innerHTML = `
            <style>
                .shadow-content {
                    padding: 10px;
                    background: #e3f2fd;
                    border-radius: 4px;
                }
                button {
                    background: #4CAF50;
                }
            </style>
            <div class="shadow-content">
                <p>This content is inside a Shadow DOM</p>
                <button>Shadow Button</button>
            </div>
        `;

        // Nested Shadow DOM Component
        const nestedShadowHost = document.getElementById('nested-shadow-host');
        const nestedShadow = nestedShadowHost.attachShadow({ mode: 'open' });
        nestedShadow.innerHTML = `
            <style>
                .outer-shadow { padding: 10px; background: #fff3e0; border-radius: 4px; }
            </style>
            <div class="outer-shadow">
                <p>Outer Shadow DOM</p>
                <div id="inner-shadow-host"></div>
            </div>
        `;
        
        const innerShadowHost = nestedShadow.querySelector('#inner-shadow-host');
        const innerShadow = innerShadowHost.attachShadow({ mode: 'open' });
        innerShadow.innerHTML = `
            <style>
                .inner-shadow { padding: 10px; background: #f3e5f5; border-radius: 4px; }
            </style>
            <div class="inner-shadow">
                <p>Inner Shadow DOM (Nested)</p>
                <button>Nested Shadow Button</button>
            </div>
        `;

        // Dynamic DOM manipulation
        let elementCounter = 0;
        document.getElementById('add-element').addEventListener('click', () => {
            const container = document.getElementById('dynamic-container');
            const newElement = document.createElement('p');
            newElement.textContent = `Dynamic element ${++elementCounter}`;
            newElement.id = `dynamic-${elementCounter}`;
            container.appendChild(newElement);
        });

        document.getElementById('remove-element').addEventListener('click', () => {
            const container = document.getElementById('dynamic-container');
            if (container.children.length > 1) {
                container.removeChild(container.lastChild);
            }
        });

        document.getElementById('modify-element').addEventListener('click', () => {
            const container = document.getElementById('dynamic-container');
            if (container.children.length > 0) {
                const lastChild = container.lastChild;
                lastChild.textContent = `Modified at ${new Date().toLocaleTimeString()}`;
                lastChild.style.color = '#' + Math.floor(Math.random()*16777215).toString(16);
            }
        });

        // Custom Web Component
        class CustomCard extends HTMLElement {
            constructor() {
                super();
                const shadow = this.attachShadow({ mode: 'open' });

                const title = this.getAttribute('title') || 'Card Title';
                const description = this.getAttribute('description') || 'Card description';

                shadow.innerHTML = `
                    <style>
                        .card {
                            border: 1px solid #ddd;
                            border-radius: 8px;
                            padding: 16px;
                            background: white;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        }
                        .card-title {
                            font-size: 18px;
                            font-weight: bold;
                            margin: 0 0 8px 0;
                            color: #2196F3;
                        }
                        .card-description {
                            margin: 0;
                            color: #666;
                        }
                        .card-actions {
                            margin-top: 12px;
                        }
                        button {
                            background: #FF9800;
                            padding: 6px 12px;
                            border: none;
                            border-radius: 4px;
                            color: white;
                            cursor: pointer;
                        }
                    </style>
                    <div class="card">
                        <h3 class="card-title">${title}</h3>
                        <p class="card-description">${description}</p>
                        <div class="card-actions">
                            <button>Action 1</button>
                            <button>Action 2</button>
                        </div>
                    </div>
                `;
            }
        }

        customElements.define('custom-card', CustomCard);

        console.log('Shadow DOM test page loaded');
        
        // ========== WORKAROUND: Mock kmpJsBridge for testing ==========
        // Since real kmpJsBridge injection is not working, we create a simple mock
        // that stores messages and allows Kotlin to poll them
        if (!window.kmpJsBridge) {
            console.log('[Mock] Creating fake kmpJsBridge for testing...');
            window.__jsToKotlinQueue__ = [];
            window.kmpJsBridge = {
                callNative: function(methodName, params, callback) {
                    console.log('[Mock] callNative:', methodName, params);
                    // Store message for Kotlin to poll
                    window.__jsToKotlinQueue__.push({
                        method: methodName,
                        params: params,
                        timestamp: Date.now()
                    });
                    
                    // WORKAROUND: Store full message data and signal via title
                    if (methodName === 'webEditMessage') {
                        const msgData = JSON.parse(params);
                        if (msgData.type === 'DOMTreeUpdated') {
                            // Store the full DOM tree data globally
                            window.__domTreeData__ = msgData.data.root;
                            
                            // Count elements and shadow hosts
                            const countElements = (el) => {
                                if (!el || !el.children) return 1;
                                return 1 + el.children.reduce((sum, child) => sum + countElements(child), 0);
                            };
                            const countShadowHosts = (el) => {
                                if (!el || !el.children) return el.isShadowHost ? 1 : 0;
                                return (el.isShadowHost ? 1 : 0) + el.children.reduce((sum, child) => sum + countShadowHosts(child), 0);
                            };
                            
                            const totalEls = countElements(msgData.data.root);
                            const shadowHosts = countShadowHosts(msgData.data.root);
                            
                            // Signal with comprehensive stats
                            document.title = `DOM_READY_${totalEls}_ELEMENTS_${shadowHosts}_SHADOWS`;
                            console.log('[Mock] DOM Tree ready:', totalEls, 'elements,', shadowHosts, 'shadow hosts');
                        }
                    }
                    
                    // Simulate async callback
                    if (callback) {
                        setTimeout(() => callback('ok'), 10);
                    }
                }
            };
            console.log('[Mock] Fake kmpJsBridge created');
        }
        
        // ========== Inline WebEdit Bridge for Testing ==========
        // Since evaluateJavaScript may not work reliably, we inline the bridge here
        if (!window.webEditBridge) {
            console.log('[Inline] Creating webEditBridge...');
            window.webEditBridge = {
                inspectMode: false,
                
                getDOMTree: function() {
                    console.log('[Inline] getDOMTree called');
                    const buildTree = (el, depth) => {
                        if (depth > 8) return null;
                        const rect = el.getBoundingClientRect();
                        const node = {
                            id: Date.now().toString(36) + Math.random().toString(36).slice(2, 11),
                            tagName: el.tagName.toLowerCase(),
                            selector: el.id ? `#${el.id}` : el.tagName.toLowerCase(),
                            textContent: (el.textContent || '').trim().substring(0, 50),
                            attributes: {},
                            boundingBox: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },
                            children: [],
                            isShadowHost: !!el.shadowRoot,
                            inShadowRoot: false
                        };
                        
                        // Add key attributes
                        if (el.id) node.attributes.id = el.id;
                        if (el.className) node.attributes.class = el.className;
                        
                        // Process children
                        Array.from(el.children).slice(0, 30).forEach(child => {
                            const childNode = buildTree(child, depth + 1);
                            if (childNode) node.children.push(childNode);
                        });
                        
                        // Process shadow children
                        if (el.shadowRoot) {
                            Array.from(el.shadowRoot.children).slice(0, 30).forEach(child => {
                                const childNode = buildTree(child, depth + 1);
                                if (childNode) {
                                    childNode.inShadowRoot = true;
                                    node.children.push(childNode);
                                }
                            });
                        }
                        
                        return node;
                    };
                    
                    const tree = buildTree(document.body, 0);
                    console.log('[Inline] Tree built, sending to Kotlin...');
                    
                    // Send to Kotlin
                    if (window.kmpJsBridge && window.kmpJsBridge.callNative) {
                        const message = JSON.stringify({
                            type: 'DOMTreeUpdated',
                            data: { root: tree }
                        });
                        window.kmpJsBridge.callNative('webEditMessage', message);
                        console.log('[Inline] DOMTreeUpdated sent to Kotlin');
                    }
                }
            };
            
            // Auto-send DOM tree when kmpJsBridge is ready
            const waitForBridge = () => {
                if (window.kmpJsBridge && window.kmpJsBridge.callNative) {
                    console.log('[Inline] kmpJsBridge available, auto-sending initial DOM tree...');
                    window.webEditBridge.getDOMTree();
                } else {
                    console.log('[Inline] Waiting for kmpJsBridge...');
                    setTimeout(waitForBridge, 200);
                }
            };
            setTimeout(waitForBridge, 500);
        }
        
        // Additional helper: Force refresh DOM tree on demand
        window.refreshDOMTree = function() {
            if (window.webEditBridge && window.webEditBridge.getDOMTree) {
                window.webEditBridge.getDOMTree();
                return true;
            }
            return false;
        };
    </script>
</body>
</html>

